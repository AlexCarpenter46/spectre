// Distributed under the MIT License.
// See LICENSE.txt for details.

#include "Parallel/Printf/Printf.hpp"

#include <cstdio>
#include <vector>

#include "Utilities/System/ParallelInfo.hpp"

namespace {
void do_print(const bool error, const std::vector<char>& message) {
  FILE* const stream = error ? stderr : stdout;
  // fprintf is atomic and threadsafe within a single process (via
  // locks).  See flockfile(3).

  // cert-err33-c: False positive: "The return value of a call to
  // fprintf() ... may be ignored if the output is being directed to
  // stdout or stderr."

  // cppcoreguidelines-pro-type-vararg: I cannot change the signature
  // of fprintf.

  // NOLINTNEXTLINE(cert-err33-c,cppcoreguidelines-pro-type-vararg)
  fprintf(stream, "%s", message.data());
}
}  // namespace

namespace Parallel {
namespace detail {
void send_message(const bool error, const std::vector<char>& message) {
  if (printer_chare_is_set and sys::my_node() != 0) {
    printer_chare[0].print(error, message);
  } else {
    do_print(error, message);
  }
}
}  // namespace detail

void PrinterChare::print(const bool error, const std::vector<char>& message) {
  do_print(error, message);
}

void PrinterChare::register_with_charm() {
  // From the code generated by charm from the ci file.
  _registerPrintf();
}

// NOLINTNEXTLINE(cppcoreguidelines-avoid-non-const-global-variables)
CProxy_PrinterChare printer_chare;
// NOLINTNEXTLINE(cppcoreguidelines-avoid-non-const-global-variables)
bool printer_chare_is_set;
}  // namespace Parallel

#include "Parallel/Printf/Printf.def.h"
