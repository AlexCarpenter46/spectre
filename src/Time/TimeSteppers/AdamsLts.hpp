// Distributed under the MIT License.
// See LICENSE.txt for details.

#pragma once

#include <boost/container/small_vector.hpp>
#include <cstddef>
#include <tuple>
#include <utility>

#include "Time/TimeStepId.hpp"
#include "Time/TimeSteppers/AdamsCoefficients.hpp"

/// \cond
namespace TimeSteppers {
template <typename T>
class BoundaryHistoryEvaluator;
class ConstBoundaryHistoryTimes;
class MutableBoundaryHistoryTimes;
}  // namespace TimeSteppers
namespace gsl {
template <class T>
class not_null;
}  // namespace gsl
/// \endcond

/// Shared LTS implementation for the two Adams-based methods.
namespace TimeSteppers::adams_lts {
/// Storage for LTS coefficients that should not allocate in typical
/// cases.  The contents should be kept sorted.
/// @{

// For order-k 2:1 stepping, in each small step, half the points will
// require interpolation (k entries each) and the others will not (1
// entry each).  So (2 small steps) * ((k/2 interpolations) * (from k
// points) + (k/2 non-interpolations)) = k (k + 1).  (The small steps
// round k/2 in different directions and the effect cancels out.)
constexpr size_t lts_coefficients_static_size =
    adams_coefficients::maximum_order * (adams_coefficients::maximum_order + 1);
struct LtsCoefficients
    : boost::container::small_vector<std::tuple<TimeStepId, TimeStepId, double>,
                                     lts_coefficients_static_size> {
  using boost::container::small_vector<
      std::tuple<TimeStepId, TimeStepId, double>,
      lts_coefficients_static_size>::small_vector;
};
/// @}

LtsCoefficients& operator+=(LtsCoefficients& a, const LtsCoefficients& b);
LtsCoefficients& operator-=(LtsCoefficients& a, const LtsCoefficients& b);

LtsCoefficients operator+(LtsCoefficients&& a, LtsCoefficients&& b);
LtsCoefficients operator+(LtsCoefficients&& a, const LtsCoefficients& b);
LtsCoefficients operator+(const LtsCoefficients& a, LtsCoefficients&& b);
LtsCoefficients operator+(const LtsCoefficients& a, const LtsCoefficients& b);

LtsCoefficients operator-(LtsCoefficients&& a, const LtsCoefficients& b);
LtsCoefficients operator-(const LtsCoefficients& a, const LtsCoefficients& b);

/// Add the LTS boundary terms for to \p result for the given set of
/// coefficients.
template <typename T>
void apply_coefficients(gsl::not_null<T*> result,
                        const LtsCoefficients& coefficients,
                        const BoundaryHistoryEvaluator<T>& coupling);

/// Type of step to calculate coefficients for.
enum class StepType { Explicit, Predictor, Corrector };

#if defined(__clang__) and __clang__ < 17
#pragma GCC diagnostic push
// Clang is upset about \tparam for some reason.  Doxygen is happy.
#pragma GCC diagnostic ignored "-Wdocumentation"
#endif
/// Calculate the nonzero terms in the LTS boundary contribution.
///
/// All entries will have distinct pairs of IDs.
///
/// \tparam TimeType The type `Time` for a substep or
/// `ApproximateTime` for dense output.
///
/// \returns Container of tuples of `(local_id, remote_id, coefficient)`.
template <typename TimeType>
LtsCoefficients lts_coefficients(const ConstBoundaryHistoryTimes& local_times,
                                 const ConstBoundaryHistoryTimes& remote_times,
                                 const TimeType& end_time, StepType step_type);
#if defined(__clang__) and __clang__ < 17
#pragma GCC diagnostic pop
#endif

// FIXME docs, remove unused stuff
enum class SchemeType { Explicit, Implicit };

struct AdamsScheme {
  SchemeType type;
  size_t order;
};

bool operator==(const AdamsScheme& a, const AdamsScheme& b);
bool operator!=(const AdamsScheme& a, const AdamsScheme& b);

template <typename TimeType>
LtsCoefficients lts_coefficients2(const ConstBoundaryHistoryTimes& local_times,
                                  const ConstBoundaryHistoryTimes& remote_times,
                                  const Time& start_time,
                                  const TimeType& end_time,
                                  const AdamsScheme& local_scheme,
                                  const AdamsScheme& remote_scheme,
                                  const AdamsScheme& small_step_scheme);

/// Remove old entries from the BoundaryHistory.
///
/// Removes any entries that are unnecessary for taking explicit steps
/// of order \p integration_order starting from the end of \p
/// local_times.  The order is not taken from the history because it
/// will be lower for predictor phases.
///
/// For a predictor-corrector method the corrector needs a superset of
/// the data used by the predictor, so no cleaning is needed in the
/// corrector phase.
void clean_boundary_history(const MutableBoundaryHistoryTimes& local_times,
                            const MutableBoundaryHistoryTimes& remote_times,
                            const size_t integration_order);

// FIXME doc
void clean_boundary_history2(const MutableBoundaryHistoryTimes& times,
                             const Time& first_needed_time,
                             const size_t steps_to_keep);
}  // namespace TimeSteppers::adams_lts
