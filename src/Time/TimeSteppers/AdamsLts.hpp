// Distributed under the MIT License.
// See LICENSE.txt for details.

#pragma once

#include <boost/container/small_vector.hpp>
#include <cstddef>
#include <tuple>

#include "Time/TimeStepId.hpp"
#include "Time/TimeSteppers/AdamsCoefficients.hpp"

/// \cond
class Time;
namespace TimeSteppers {
template <typename T>
class BoundaryHistoryEvaluator;
class ConstBoundaryHistoryTimes;
}  // namespace TimeSteppers
namespace gsl {
template <class T>
class not_null;
}  // namespace gsl
/// \endcond

/// Shared LTS implementation for the two Adams-based methods.
namespace TimeSteppers::adams_lts {
/// Get the time of a substep as a `Time`, assuming substeps are at
/// the end of the step.
Time exact_substep_time(const TimeStepId& id);

// For order-k 2:1 stepping, in each small step, half the points will
// require interpolation (k entries each) and the others will not (1
// entry each).  So (2 small steps) * ((k/2 interpolations) * (from k
// points) + (k/2 non-interpolations)) = k (k + 1).  (The small steps
// round k/2 in different directions and the effect cancels out.)
constexpr size_t lts_coefficients_static_size =
    adams_coefficients::maximum_order * (adams_coefficients::maximum_order + 1);

/// Storage for LTS coefficients that should not allocate in typical
/// cases.  Each entry is a tuple of (local id, remote id,
/// coefficient).  The contents should be kept sorted, as some
/// functions assume that.
struct LtsCoefficients
    : boost::container::small_vector<std::tuple<TimeStepId, TimeStepId, double>,
                                     lts_coefficients_static_size> {
  using boost::container::small_vector<
      std::tuple<TimeStepId, TimeStepId, double>,
      lts_coefficients_static_size>::small_vector;
};

LtsCoefficients& operator+=(LtsCoefficients& a, const LtsCoefficients& b);
LtsCoefficients& operator-=(LtsCoefficients& a, const LtsCoefficients& b);

LtsCoefficients operator+(LtsCoefficients&& a, LtsCoefficients&& b);
LtsCoefficients operator+(LtsCoefficients&& a, const LtsCoefficients& b);
LtsCoefficients operator+(const LtsCoefficients& a, LtsCoefficients&& b);
LtsCoefficients operator+(const LtsCoefficients& a, const LtsCoefficients& b);

LtsCoefficients operator-(LtsCoefficients&& a, LtsCoefficients&& b);
LtsCoefficients operator-(LtsCoefficients&& a, const LtsCoefficients& b);
LtsCoefficients operator-(const LtsCoefficients& a, LtsCoefficients&& b);
LtsCoefficients operator-(const LtsCoefficients& a, const LtsCoefficients& b);

/// Add the LTS boundary terms for to \p result for the given set of
/// coefficients.
template <typename T>
void apply_coefficients(gsl::not_null<T*> result,
                        const LtsCoefficients& coefficients,
                        const BoundaryHistoryEvaluator<T>& coupling);

/// Type of coefficients used for an AdamsScheme
enum class SchemeType { Explicit, Implicit };

struct AdamsScheme {
  SchemeType type;
  size_t order;
};

bool operator==(const AdamsScheme& a, const AdamsScheme& b);
bool operator!=(const AdamsScheme& a, const AdamsScheme& b);

/*!
 * Calculate the nonzero terms in an Adams LTS boundary contribution.
 *
 * The coefficients are generated for a step from \p start_time to \p
 * end_time, integrating using the \p small_step_scheme.
 * Interpolation from the elements is performed using polynomials
 * appropriate for the given \p local_scheme and \p remote_scheme.
 *
 * This function returns the sum of the coefficients for the small
 * steps, i.e., the steps between all the times either side updates
 * between the time bounds.  Each small step is calculated as
 *
 * \f{equation}
 * \Delta \tilde{y}_n = \Delta \tilde{t}_n \sum_{ij} D(y^L_{n,-i}, y^R_{n,-j})
 * \sum_q \tilde{\alpha}_{nq}
 * \ell_i(\tilde{t}_{n-q}; t^L_\cdots, \ldots)
 * \ell_j(\tilde{t}_{n-q}; t^R_\cdots, \ldots),
 * \f}
 *
 * where $y^L_{n,0}$ and $y^R_{n,0}$ are the values of the local and
 * remote variables at the start of the step containing small step
 * $n$, $y^L_{n,1}$ and $y^R_{n,1}$ are the predictor values for those
 * steps, and other index values count backwards in the history of
 * that side.  The range of $i$ and choice of the control times
 * $t^L_\cdots$ are determined by \p local_scheme, $j$ and
 * $t^R_\cdots$ are determined by \p remote_scheme, and the Adams
 * coefficients $\tilde{\alpha}_{nq}$ correspond to \p
 * small_step_scheme.
 *
 * When called for dense output, the arguments must represent a
 * single small step, i.e., the step cannot cross any of the control
 * times.  Any additional terms can be generated by a second call
 * treating the remainder of the step as non-dense.
 *
 * \tparam TimeType The type `Time` for a step aligned with the
 * control times or `ApproximateTime` for dense output.
 */
template <typename TimeType>
LtsCoefficients lts_coefficients(const ConstBoundaryHistoryTimes& local_times,
                                 const ConstBoundaryHistoryTimes& remote_times,
                                 const Time& start_time,
                                 const TimeType& end_time,
                                 const AdamsScheme& local_scheme,
                                 const AdamsScheme& remote_scheme,
                                 const AdamsScheme& small_step_scheme);
}  // namespace TimeSteppers::adams_lts
